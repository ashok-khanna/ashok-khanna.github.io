<html>
<head>
	<title>Common Lisp Condition System</title>
	<script type="text/javascript" src="/scripts/highlight-lisp.js"></script>
	<link rel="stylesheet" href="/css/emacs-face.css">
	<link rel="stylesheet" type="text/css" href="/css/lisp.css">
</head>
<body>
<main>
<h1>Overview & Tutorial of the Common Lisp Condition System</h1>
<p>By Ashok Khanna</p>
<p>Sunday, 23 May 2021</p>
<br />
<p>This guide introduces the Common Lisp Condition System</p>


<h2>Conceptual Background</h2>

<div class="note">The below are extracts from Chapter 29 of <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node312.html">Common Lisp the Language, 2nd Edition</a> and <a href="https://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html">Exceptional Situations in Lisp</a>, both written by <a href="https://en.wikipedia.org/wiki/Kent_Pitman">Kent M. Pitman</a>, and only lightly edited to conform to the style of this guide.</div>

<p>It is useful to partition the description of a program's behavior into two parts - what happens in normal situations, and what happens in exceptional situations. For example, consider a function <i>f</i> defined to allow only integer arguments but also guaranteed to detect and signal an error for non-integer arguments. Such a description would be internally inconsistent (that is, paradoxical) because the function's behavior is well-defined for non-integers. Yet we would not want this annoying paradox to force description of <i>f</i> as a function that accepts any kind of argument (just in case <i>f</i> is being called only as a quick way to signal an error, for example). Using the normal/exceptional distinction, we can say clearly that f accepts integers in the normal situation and signals an error in exceptional situations. Moreover, we can say that when we refer to the definition of a function informally, it is acceptable to speak only of its normal behavior. For example, we can speak informally about <i>f</i> as a function that accepts only integers without feeling that we are committing some awful fraud.</p>

<p>The separation of normal and exceptional situations is useful for a number of reasons, including the following:</p>

<ul>
	<li><b>Simplifying Assumptions</b>: A programmer may speed the development of a program by assuming that the program will be needed only for some normal case. In so doing, the programmer pushes off worrying about a level of detail that would only be distracting during the prototyping phase. Later, after it has been shown that the program works satisfactorily in normal situations, the programmer can "tighten up" the program to handle exceptional situations</li>
	<li><b>Presentation</b>: Simplifying assumptions can also be important after a program has been developed--when it is being read by another programmer. The person reading the code may want to first understand what it does in the normal situation and then later refine his understanding of it by inspecting its behavior in exceptional situations. If the code for dealing with the normal situation is thickly interspersed with code attempting to recognize and deal with exceptional situations, the reader's ability to decipher the intent of the program may be greatly diminished</li>
	<li><b>Modularity</b>: It frequently happens that the same exceptional situation can occur in many different places in a program; and, in many cases, the way it should be handled is the same throughout the program. For example, consider a program which is compiling a file from a remote machine. If the remote machine crashes, the compilation will probably want to simply fail no matter what routine was running. Languages should provide some way of centralizing the information about a program's behavior in such an exceptional situation so that it doesn't have to be needlessly repeated throughout the code for the program</li>
	<li><b>Efficiency</b>: In some cases, there may be efficiency reasons for considering some cases to be exceptional. For example, the compiled code for + will be less efficient if it must contain explicit checks for its arguments being non-numbers. Thus, an implementation may choose the interpreted + function to "signal an error" if invoked with bad arguments, but allow compiled calls to + to do just "do the wrong thing" if that situation arises.</li>
</ul>

<p>In this article, we will describe how to define conditions in Common Lisp, how to signal and handle them, and how to recover from scenarios where exceptional situations occur (such as through restarting).</p>


<p></p>

<h2>Starting Notes</h2>
<p>We will use a contrived example of calculating the width from a rectangle when its area and height are known to illustrate the main concepts of the Common Lisp Condition System.</p>

<p>A simple version of this function is as follows.</p>

<code>
(defun rect-width (area height)
  (/ area height))
 </code>

<h2>Conditions</h2>


<h2>Signalling Conditions</h2>
<p>






<h2>Handling Conditions</h2>



<h2>Restarts</h2>




	<code>
;; This is a comment
;; This too

;; Basic Function




;; Trap Errors

(defun rect-width-ignore-errors (area height)
  (ignore-errors
   (/ area height)))




;; Define Conditions

(define-condition divide-by-zero (error) ())

(define-condition negative-value ()
  ((desc :initarg :desc :reader desc))
  (:report (lambda (condition stream)
             (format stream "Condition: ~a."
                     (desc condition)))))


;; Function with Signalling:

(defun rect-width-v2 (area height)
  (cond ((equal height 0)
         (error "You divided by zero"))
        ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative"))
        (t (/ area height))))


;; Wrapped within a Condition Handler:

(defun rect-width-handler-case (area height)
  (handler-case (rect-width-v2 area height)
    (divide-by-zero (condition)
      (values 0 condition))
    (negative-value (condition)
      (values 0 (let ((*print-escape* nil))
                  (write condition))))
    (error (condition)
      (values nil condition))))


;; Example of Block - Return-From:

(defun rect-width-block-return-from (area height)
  (let ((tag (gensym)))
    (block tag
      (cond ((equal height 0)
             (return-from tag (values 0 "Error - Divide by Zero")))
            ((< height 0)
             (return-from tag (values 0 "Error - Height is Negative")))
            ((< area 0)
             (return-from tag (values 0 "Error - Area is Negative")))
            (t
             (rect-width-v2 area height))))))


;; Wrapped within a handler-bind:

(defun example-handler-function (condition)
  (let ((*print-escape* nil))
    (values 0 (write condition))))


(defun rect-width-handler-bind-bad (area height)
  (handler-bind
      ((divide-by-zero #'(lambda (condition)
                           (declare (ignore condition))
                          (values nil condition)))
       (negative-value #'example-handler-function)
       (error (lambda (condition)
                (values nil condition))))
    (rect-width-v2 area height)))


(defun rect-width-handler-bind-good (area height)
  (let ((tag (gensym)))
    (block tag
      (handler-bind
          ((divide-by-zero #'(lambda (condition)
                               (return-from tag
                                 (values nil condition))))
           (negative-value #'example-handler-function)
           (error #'(lambda (condition)
                      (return-from tag (values nil condition)))))
        (rect-width-v3 area height)))))

(defun rect-width-v3 (area height)
  (cond ((equal height 0)
         (signal 'divide-by-zero))
        ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative"))
        (t (/ area height))))


;; Example of Restart Case:

;; Credits Common Lisp Cookbook

(defun prompt-value (prompt)
  (format *query-io* prompt)  ;; *query-io*: the special stream to make user queries.
  (force-output *query-io*)   ;; Ensure the user sees what he types.
  (list (read *query-io*)))   ;; We must return a list.


(defun rect-width-restart-case (area height)
  (restart-case (rect-width-v2 area height)
    (return-zero ()
      :report "Return 0"
      0)
    (new-height (value)
      :report "Enter a new height (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new height"))
      (rect-width-v2 area value))
    (new-width (value)
      :report "Enter a new area (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new area"))
      (rect-width-v2 value height))))


;; Unwind-Protect Example

(defun rect-width-unwind-protect (area height)
  ((unwind-protect (rect-width-v4 area height))))

(unwind-protect 
     (progn (start-motor) 
            (drill-hole)) 
  (stop-motor))
If drill-hole does a throw that attempts to quit out of the unwind-protect, then (stop-motor) will be executed.

This example assumes that it is correct to call stop-motor even if the motor has not yet been started. Remember that an error or interrupt may cause an exit even before any initialization forms have been executed. Any state restoration code should operate correctly no matter where in the protected code an exit occurred. For example, the following code is not correct:

(unwind-protect 
     (progn (incf *access-count*) 
            (perform-access)) 
  (decf *access-count*))

This example assumes that it is correct to call stop-motor even if the motor has not yet been started. Remember that an error or interrupt may cause an exit even before any initialization forms have been executed. Any state restoration code should operate correctly no matter where in the protected code an exit occurred. For example, the following code is not correct:

(unwind-protect 
     (progn (incf *access-count*) 
            (perform-access)) 
  (decf *access-count*))
If an exit occurs before completion of the incf operation the decf operation will be executed anyway, resulting in an incorrect value for *access-count*. The correct way to code this is as follows:

(let ((old-count *access-count*)) 
  (unwind-protect 
       (progn (incf *access-count*) 
              (perform-access)) 
    (setq *access-count* old-count)))


    </code>
<h2>Notes</h2>
<h3>Comparison to Other Languages</h3>


<h3>Acknowledgements</h3>
<p>Apart from Chapter 29 of CLTL2e, <a href="https://www.apress.com/gp/book/9781484211779">Common Lisp Recipes by Edmun Weitz</a> and the <a href="https://lispcookbook.github.io/cl-cookbook/error_handling.html">Common Lisp Cookbook</a> were helpful to me to understand the Common Lisp Condition System. Professor Weitz's book is notable for its excellent walkthrough of the restard-bind and its illustration of how the call stack unwinds. The CL Cookbook had very clear walk throughs of the restart-case macro, which I believe was based on the blog article <a href="https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/">Conditions and Restarts in Common Lisp</a> by Timmy Jose. Full credit for parts of the above article should go to these resources.</p>

<h3>Further Reading</h3>
<p>The second part of Chapter 29 of CLTL2e, <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node334.html">Program Interface to Condition System</a> and the Common Lisp HyperSpec will be relevant further reading after digesting this article. An excellent follow up would also be Kent Pitman's paper <a href="https://www.nhplace.com/kent/Papers/Condition-Handling-2001.html">Condition Handling in the Lisp Language Family</a>, which is a must read for anybody who wants to seriously apply and understand the Common Lisp Condition system. Finally, while browsing online materials, I saw Michal Herda has written a detailed book, <a href="https://www.apress.com/gp/book/9781484261330">The Common Lisp Condition System: Beyond Exception Handling with Control Flow Mechanisms</a>, that provides detailed information about the Lisp condition system and its control flow mechanisms; it also describes an example ANSI-conformant implementation of the condition system. I haven't read it, but it has <a href="https://www.amazon.ae/Common-Lisp-Condition-System-Mechanisms/dp/148426133X#customerReviews">good reviews online</a>.</p>

<p>If you have written or aware of any other useful resources to add here, do drop me an e-mail at ashok dot khanna at hotmail dot com.</p>

</main>
	<script src="/scripts/copy-to-clipboard.js"></script>
</body>
</html>