<html>
<head>
	<title>Common Lisp Condition System</title>
	<script type="text/javascript" src="/scripts/highlight-lisp.js"></script>
	<link rel="stylesheet" href="/css/emacs-face.css">
	<link rel="stylesheet" type="text/css" href="/css/lisp.css">
</head>
<body>
<main>
<h1>Overview & Tutorial of the Common Lisp Condition System</h1>
<p class="author">By Ashok Khanna</p>
<p>Sunday, 23 May 2021</p>
<p>This article provides a non-exhaustive introduction to the Common Lisp Condition System, with the aim to get quickly get you comfortable with error handling in Common Lisp and writing robust code. We will use a contrived example (refer starting notes below) and all code is self-sufficient and has been tested in SBCL. The example repo is available on GitHub as part of <a href="https://github.com/ashok-khanna/common-lisp-by-example">my ongoing tutorial series Common Lisp by Example</a>, and if you like this guide, please do star the repo!</p>

<h2>Conceptual Background</h2>

<div class="note">The below are extracts from Chapter 29 of <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node312.html">Common Lisp the Language, 2nd Edition</a> and <a href="https://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html">Exceptional Situations in Lisp</a>, both written by <a href="https://en.wikipedia.org/wiki/Kent_Pitman">Kent M. Pitman</a>, and only lightly edited to conform to the style of this guide.</div>

<p>It is useful to partition the description of a program's behavior into two parts - what happens in normal situations, and what happens in exceptional situations. For example, consider a function <i>f</i> defined to allow only integer arguments but also guaranteed to detect and signal an error for non-integer arguments. Such a description would be internally inconsistent (that is, paradoxical) because the function's behavior is well-defined for non-integers. Yet we would not want this annoying paradox to force description of <i>f</i> as a function that accepts any kind of argument (just in case <i>f</i> is being called only as a quick way to signal an error, for example). Using the normal/exceptional distinction, we can say clearly that <i>f</i> accepts integers in the normal situation and signals an error in exceptional situations. Moreover, we can say that when we refer to the definition of a function informally, it is acceptable to speak only of its normal behavior. For example, we can speak informally about <i>f</i> as a function that accepts only integers without feeling that we are committing some awful fraud.</p>

<p>The separation of normal and exceptional situations is useful for a number of reasons, including the following:</p>

<ul>
	<li><b>Simplifying Assumptions</b>: A programmer may speed the development of a program by assuming that the program will be needed only for some normal case. In so doing, the programmer pushes off worrying about a level of detail that would only be distracting during the prototyping phase. Later, after it has been shown that the program works satisfactorily in normal situations, the programmer can "tighten up" the program to handle exceptional situations</li>
	<li><b>Presentation</b>: Simplifying assumptions can also be important after a program has been developed--when it is being read by another programmer. The person reading the code may want to first understand what it does in the normal situation and then later refine his understanding of it by inspecting its behavior in exceptional situations. If the code for dealing with the normal situation is thickly interspersed with code attempting to recognize and deal with exceptional situations, the reader's ability to decipher the intent of the program may be greatly diminished</li>
	<li><b>Modularity</b>: It frequently happens that the same exceptional situation can occur in many different places in a program; and, in many cases, the way it should be handled is the same throughout the program. For example, consider a program which is compiling a file from a remote machine. If the remote machine crashes, the compilation will probably want to simply fail no matter what routine was running. Languages should provide some way of centralizing the information about a program's behavior in such an exceptional situation so that it doesn't have to be needlessly repeated throughout the code for the program</li>
	<li><b>Efficiency</b>: In some cases, there may be efficiency reasons for considering some cases to be exceptional. For example, the compiled code for + will be less efficient if it must contain explicit checks for its arguments being non-numbers. Thus, an implementation may choose the interpreted + function to "signal an error" if invoked with bad arguments, but allow compiled calls to + to do just "do the wrong thing" if that situation arises.</li>
</ul>

<p>The Common Lisp Condition System (CLCS) encapsulate and formalise useful patterns of data and control flow that are useful in dealing with exceptional situations. In this article, we will describe how to define conditions in Common Lisp, how to signal and handle them, and how to recover from scenarios where exceptional situations occur (such as through restarting).</p>


<p></p>

<h2>Starting Notes</h2>
<p>For the rest of this guide, we will use a contrived example of calculating the width from a rectangle when its area and height are known. The "normal" definition of this function would be the preceding sentence, and possible exceptional situations would include non-numerical inputs for either of area and height, passing a value of zero for height (i.e. divide by zero error) or passing in negative values for either of area and height. A simple version of this function is as follows.</p>

<code>
(defun rect-width (area height)
  (/ area height))
 </code>

<h2>Conditions</h2>
<p>Conditions are <i>interesting</i> situations in a program, one may say "exceptional" to keep in line with the terminology we used earlier, but it would also be good to keep our mind open and think of conditions as a general construct and not one limited to errors or only most exceptional situations. Errors can be defined as conditions in which normal program execution may not continue without some form of intervention (either interactively by the user or under some sort of program control). Our primary objective in most cases is to detect and handle errors.</p>

<p>Common Lisp takes an object-oriented approach to condition handling, as it allows for a more organised sharing of information related to condition handling. This approach has the following benefits over a more primitive text-based approach (per 29.3.4 of CLTL2e):</p>
<ul>
	<li>Conditions are classified according to subtype relationships, making it easy to test for categories of conditions</li>
	<li>Conditions have named slot values through which parameters are conveyed from the program that signals the condition to the program that handles it</li>
	<li>Inheritance of methods and slots reduces the amount of explicit specification necessary to achieve various interesting effects</li>
</ul>

<p>If the above is confusing, it is probably because you have not had much experience with the Common Lisp Object System (CLOS). It is well worth gaining proficiency in CLOS, but that is beyond the scope of this article. Consequently, we will try and keep our introduction of Common Lisp Conditions relativley simple and leave a more detailed purview to the reader.</p>

<p>In Common Lisp, all conditions are instances of the <mark>CONDITION</mark> class or one of its subclassses. Note that conditions are not standard objects, thus the treatment of condition objects is slightly different to CLOS objects and the standard more frequently talks about condition <i>types</i> as opposed to condition classes. Without labouring over this point too much, the main point here is that not all of mechanisms available to CLOS objects transfer over to CL condition types.</p>

<p>We can create condition types with the <mark>DEFINE-CONDITION</mark> macro and instances of condition types with the <mark>MAKE-INSTANCE</mark> function. To illustrate with an example, let us define two conditions type <mark2>divide-by-zero</mark2> and <mark2>negative-value</mark2>, the former being a simple condition of type error, the latter being a more complex example that has an attributes <mark2>desc</mark2> and <mark2>sender</mark2> where we can store pertinent information about the condition when it is detected.</p>

<code>
(define-condition divide-by-zero (error) ())

(define-condition negative-value ()
  ((desc :initarg :desc :reader desc))
  ((sender :initarg :sender :reader sender))
  (:report (lambda (condition stream)
             (format stream "Condition ~a sent by ~a."
                     (desc condition)
                     (sender condition)))))
</code>

<p>In the above, the <mark>:INITARG</mark> keyword is used to name the keyword parameter used for setting the values of desc and sender (:desc and :sender respectively - refer below make-condition example), while the <mark>:reader</mark> keyword is used to define the accessor functions for getting the values of desc and sender respectively (desc and reader). Thus, the form <mark3>(desc condition)</mark3> is used to access the value stored in desc for the condition passed-in. The <mark>:report</mark> option allows for printing with the condition reporter (when <mark>*PRINT-ESCAPE*</mark> is NIL - refer below examples), which is the lambda function in the above. Note that we can use a constant string in place of the lambda function above.</p>

<p>To make an instance of a condition, we can use the <mark>MAKE-CONDITION</mark> function:</p>

<code>
	(make-condition 'divide-by-zero)
	(make-condition 'negative-value :desc "Height is Negative"
	                                :sender "the RECT-WIDTH function")
</code>
<p>To end this section, note that useful further reading is <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node346.html">29.5. Condition Types of CLTL2e</a>, which is a listing of the predefined condition types.</p>

<h2>Signalling Conditions</h2>
<p>Conceptually, signalling an error in a program is an admission by that program that is does not know how to continue and requires external intervention. Once an error is singled, any decision about how to continue must come from the outside. The <mark>SIGNAL</mark> function signals a condition without requiring it to be handled by a condition handler. On the other hand, we use the <mark>ERROR</mark> function if we want to signal an error and require the debugger to be entered if the condition is not handled.</p>

<p>Below is an example of rewriting our contrived RECT-WIDTH function to analyse its inputs and detect negative value and zero value inputs. Note that we do not detect non-numerical inputs in the below (we will catch them later in this article). In the below example, we illustrate three ways to specify conditions, noting the second or third way is what you will most likely use:</p>

<ul>
	<li>Supplying one argument - a condition object, as in the form <mark4>(signal (make-condition ... ))</mark4> in the above</li>
	<li>Supplying arguments as one would for make-condition, as in the second example above</li>
	<li>Supplying arguments as one would do for the FORMAT function, but without the stream details, such as in <mark4>(error "You divided by Zero")</mark4> in the third example above (or as another illustrative example, one could do <mark4>(warn "You divided by ~a" 0)</mark4>). In such approaches, the condition is of the default type as specified by the function called (e.g. error or warning)</li>
</ul>

<code>
(defun rect-width-v2 (area height)
  (cond ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative" :sender "Ashok")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative" :sender "Ashok"))
        ((equal height 0)
         (error "You divided by zero"))
        (t (/ area height))))
</code>

<p>It is worth re-iterating that the SIGNAL function does not require the condition signalled to be handled, while the ERROR function requires it to be handled or otherwise will throw us into the debugger.</p>




<h3>CERROR & WARNING (Optional)</h3>
<p><mark>CERROR</mark> is an alternative to the error function, which allows the programmer to specifiy a <i>single</i> well-defined recovery strategy. Below is an example. <mark>WARN</mark> does not enter the debugger but as a side effect apply the aforementioned condition reporter to the *ERROR-OUTPUT* stream. Warn only works with conditions of type WARNING. We won't discuss CERROR or WARN here further, they are included here for completeness. Note that SIGNAL is the primitive mechanism for signalling conditions, and ERROR, CERROR and WARN are useful abstractions build over SIGNAL.</p>

<code>
(defun example-divide-fn (numerator denominator)
   (cond ((equal denominator 0)
          (cerror
            "Divide by 1 instead"
            "~a cannot be zero." denominator)
           (/ numerator 1))
         (t (/ numerator denominator))))
</code>


<h2>Handling Conditions</h2>



<h2>Restarts</h2>




	<code>
;; This is a comment
;; This too

;; Basic Function




;; Trap Errors

(defun rect-width-ignore-errors (area height)
  (ignore-errors
   (/ area height)))




;; Define Conditions




;; Function with Signalling:

(defun rect-width-v2 (area height)
  (cond ((equal height 0)
         (error "You divided by zero"))
        ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative"))
        (t (/ area height))))


;; Wrapped within a Condition Handler:

(defun rect-width-handler-case (area height)
  (handler-case (rect-width-v2 area height)
    (divide-by-zero (condition)
      (values 0 condition))
    (negative-value (condition)
      (values 0 (let ((*print-escape* nil))
                  (write condition))))
    (error (condition)
      (values nil condition))))


;; Example of Block - Return-From:

(defun rect-width-block-return-from (area height)
  (let ((tag (gensym)))
    (block tag
      (cond ((equal height 0)
             (return-from tag (values 0 "Error - Divide by Zero")))
            ((< height 0)
             (return-from tag (values 0 "Error - Height is Negative")))
            ((< area 0)
             (return-from tag (values 0 "Error - Area is Negative")))
            (t
             (rect-width-v2 area height))))))


;; Wrapped within a handler-bind:

(defun example-handler-function (condition)
  (let ((*print-escape* nil))
    (values 0 (write condition))))


(defun rect-width-handler-bind-bad (area height)
  (handler-bind
      ((divide-by-zero #'(lambda (condition)
                           (declare (ignore condition))
                          (values nil condition)))
       (negative-value #'example-handler-function)
       (error (lambda (condition)
                (values nil condition))))
    (rect-width-v2 area height)))


(defun rect-width-handler-bind-good (area height)
  (let ((tag (gensym)))
    (block tag
      (handler-bind
          ((divide-by-zero #'(lambda (condition)
                               (return-from tag
                                 (values nil condition))))
           (negative-value #'example-handler-function)
           (error #'(lambda (condition)
                      (return-from tag (values nil condition)))))
        (rect-width-v3 area height)))))

(defun rect-width-v3 (area height)
  (cond ((equal height 0)
         (signal 'divide-by-zero))
        ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative"))
        (t (/ area height))))


;; Example of Restart Case:

;; Credits Common Lisp Cookbook

(defun prompt-value (prompt)
  (format *query-io* prompt)  ;; *query-io*: the special stream to make user queries.
  (force-output *query-io*)   ;; Ensure the user sees what he types.
  (list (read *query-io*)))   ;; We must return a list.


(defun rect-width-restart-case (area height)
  (restart-case (rect-width-v2 area height)
    (return-zero ()
      :report "Return 0"
      0)
    (new-height (value)
      :report "Enter a new height (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new height"))
      (rect-width-v2 area value))
    (new-width (value)
      :report "Enter a new area (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new area"))
      (rect-width-v2 value height))))


;; Unwind-Protect Example

(defun rect-width-unwind-protect (area height)
  ((unwind-protect (rect-width-v4 area height))))

(unwind-protect 
     (progn (start-motor) 
            (drill-hole)) 
  (stop-motor))
If drill-hole does a throw that attempts to quit out of the unwind-protect, then (stop-motor) will be executed.

This example assumes that it is correct to call stop-motor even if the motor has not yet been started. Remember that an error or interrupt may cause an exit even before any initialization forms have been executed. Any state restoration code should operate correctly no matter where in the protected code an exit occurred. For example, the following code is not correct:

(unwind-protect 
     (progn (incf *access-count*) 
            (perform-access)) 
  (decf *access-count*))

This example assumes that it is correct to call stop-motor even if the motor has not yet been started. Remember that an error or interrupt may cause an exit even before any initialization forms have been executed. Any state restoration code should operate correctly no matter where in the protected code an exit occurred. For example, the following code is not correct:

(unwind-protect 
     (progn (incf *access-count*) 
            (perform-access)) 
  (decf *access-count*))
If an exit occurs before completion of the incf operation the decf operation will be executed anyway, resulting in an incorrect value for *access-count*. The correct way to code this is as follows:

(let ((old-count *access-count*)) 
  (unwind-protect 
       (progn (incf *access-count*) 
              (perform-access)) 
    (setq *access-count* old-count)))


    </code>
<h2>Notes</h2>
<h3>Comparison to Other Languages</h3>
<p>One of the main distinctions between Common Lisp's error handling from that of other programming languages is that Common Lisp decouples the act of signalling an error and handling one. This is well explained by Peter Seibel in <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">Chapter 19 Beyond Error Handling of Practical Common Lisp</a>, so let us re-use some extracts from that chapter:</p>
<div class="note"><p>The condition system is more flexible than exception systems because instead of providing a two-part division between the code that signals an error and the code that handles it, the condition system splits the responsibilities into three parts--signaling a condition, handling it, and restarting.</p>

<p>...</p>

<p>In most languages, errors are handled by returning from a failing function and giving the caller the choice of either recovering or failing itself. Some languages use the normal function return mechanism, while languages with exceptions return control by throwing or raising an exception. Exceptions are a vast improvement over using normal function returns, but both schemes suffer from a common flaw: while searching for a function that can recover, the stack unwinds, which means code that might recover has to do so without the context of what the lower-level code was trying to do when the error actually occurred.</p>

<p>...</p>

<p>Consider the hypothetical call chain of <i>high</i>, <i>medium</i>, <i>low</i>. If <i>low</i> fails and <i>medium</i> can't recover, the ball is in <i>high's</i> court. For <i>high</i> to handle the error, it must either do its job without any help from <i>medium</i> or somehow change things so calling <i>medium</i> will work and call it again. The first option is theoretically clean but implies a lot of extra code--a whole extra implementation of whatever it was <i>medium</i> was supposed to do. And the further the stack unwinds, the more work that needs to be redone. The second option--patching things up and retrying--is tricky; for <i>high</i> to be able to change the state of the world so a second call into <i>medium</i> won't end up causing an error in <i>low</i>, it'd need an unseemly knowledge of the inner workings of both <i>medium</i> and <i>low</i>, contrary to the notion that each function is a black box.</p>

<p>...</p>

<h4>The Lisp Way</h4>

<p>Common Lisp's error handling system gives you a way out of this conundrum by letting you separate the code that actually recovers from an error from the code that decides how to recover. Thus, you can put recovery code in low-level functions without committing to actually using any particular recovery strategy, leaving that decision to code in high-level functions.</p>
</div>

<p>At the end of the day, one can implement any system within any language. With that note, the main benefit of Common Lisp is being more naturally expressive of the useful distinction between normal situations, exceptional situations and the process for handling them. Thus, the conceptual background noted above is a worthwhile section to re-read, to ingrain some of the important conceptual benefits of carefully selecting appropriate error handling in your code.</p>

<h3>Acknowledgements</h3>
<p>Apart from Chapter 29 of CLTL2e, <a href="https://www.apress.com/gp/book/9781484211779">Common Lisp Recipes by Edmun Weitz</a>, <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp by Peter Seibel</a> and the <a href="https://lispcookbook.github.io/cl-cookbook/error_handling.html">Common Lisp Cookbook</a> were helpful to me to understand the Common Lisp Condition System. Professor Weitz's book is notable for its excellent walkthrough of the handler-bind macro and its illustration of how the call stack unwinds. The CL Cookbook had very clear walk throughs of the restart-case macro, which I believe was based on the blog article <a href="https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/">Conditions and Restarts in Common Lisp</a> by Timmy Jose. I have referenced Practical Common Lisp directly above, it provided a very good explaination of the benefits of the Common Lisp approach. Full credit for parts of the above article should go to these resources.</p>

<h3>Further Reading & Contact Details</h3>
<p>The second part of Chapter 29 of CLTL2e, <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node334.html">Program Interface to Condition System</a> and the Common Lisp HyperSpec will be relevant further reading after digesting this article. An excellent follow up would also be Kent Pitman's paper <a href="https://www.nhplace.com/kent/Papers/Condition-Handling-2001.html">Condition Handling in the Lisp Language Family</a>, which is a must read for anybody who wants to seriously apply and understand the Common Lisp Condition System. Finally, while browsing online materials, I saw Michal Herda has written a detailed book, <a href="https://www.apress.com/gp/book/9781484261330">The Common Lisp Condition System: Beyond Exception Handling with Control Flow Mechanisms</a>, that provides detailed information about the Lisp condition system and its control flow mechanisms; it also describes an example ANSI-conformant implementation of the condition system. I haven't read it, but it has <a href="https://www.amazon.ae/Common-Lisp-Condition-System-Mechanisms/dp/148426133X#customerReviews">good reviews online</a>.</p>

<p>If you have written or aware of any other useful resources to add here, do drop me an e-mail at ashok dot khanna at hotmail dot com. Feel free to also send any suggestions for improvement for the above article.</p>

</main>
	<script src="/scripts/copy-to-clipboard.js"></script>
</body>
</html>