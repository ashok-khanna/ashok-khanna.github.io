<html>
<head>
	<title>Common Lisp Conditions</title>
	<script type="text/javascript" src="/scripts/highlight-lisp.js"></script>
	<link rel="stylesheet" href="/css/emacs-face.css">
	<link rel="stylesheet" type="text/css" href="/css/lisp.css">
</head>
<body>
<main>
<h1>Overview & Tutorial of the Common Lisp Condition System</h1>

<p class="author">By Ashok Khanna</p>

<p>The robustness of a computer system is characterised by its ability to cope with errors during execution and with errors during input. Robustness is an important requirement for programmers as evolve from developing applications for self-use, an environment they can personally control, to developing applications for the greater population or for use in larger teams, scenarios in which they must relinquish control and where there is a much higher expectation of reliability, the ability to provide failure-free software operation for extended periods of time.</p>

<p>The Common Lisp Condition System is the language's facility for error handling. It takes an abstract approach that generalises the concept of an error and decouples the act of detecting and announcing an error from the act of handling one. In this, it differs from the catch/throw mechanism of other languages where these two stages are typically interwined such that the local state of functions that detect errors tend to automatically unwind (i.e. are lost) as part of the act of throwing errors and passing control to their handlers.<p>

<p>This is not to say you cannot replicate the error handling behaviour of other languages in Common Lisp - you can. The main point here is that Common Lisp provides greater diversity in the range of responses you can implement to manage exceptional situations. The benefits of this greater flexibility will be for you to decide as you write your own programs (there is a brief note on this topic in Section 8.1 below); today's article aims to introduce you to the implementation in Common Lisp and not to enter into a discussion of the correct approach. Such a discussion should require a deeper understanding of language design and error handling and is not appropriate for this relatively introductory article.</p>

<p>Whilst this guide is prescriptive to some degree, it would take too much time to cover all the nuances of the Common Lisp Condition System. Thus, the aim is to discuss the main concepts, and the reader is persuasively recommended to carefully read the Common Lisp HyperSpec and challenge their understanding by writing their own examples that test the boundaries of the language specification and their own understanding. Whilst this topic is not for the faint-hearted, with a reasonable amount of effort (1 week), you should be able to gain a strong understanding of error handling in Lisp and your code will be better off for it.</p>

<p>The example repo is available on GitHub as part of <a href="https://github.com/ashok-khanna/common-lisp-by-example">my ongoing tutorial series Common Lisp by Example</a>. If you like this guide, please do star the repo! And without further ado, let's get started.</p>


<div class="note"><b>Important Disclaimer</b>: Much of this guide is extracted ad verbatim Chapter 29 of <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node312.html">Common Lisp the Language, 2nd Edition</a> and <a href="https://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html">Exceptional Situations in Lisp</a>, both written by <a href="https://en.wikipedia.org/wiki/Kent_Pitman">Kent M. Pitman</a>, together with specifications from the Common Lisp HyperSpec. For the sake of readability, each passage is not directly referenced, but you can assume most of the article is from these sources and most of my efforts have been to organise the material in a form that helped me understand this topic. Other sources are referenced as they appear.</div>

<h2>Conceptual Background</h2>

<p>It is useful to partition the description of a program's behavior into two parts - what happens in normal situations, and what happens in exceptional situations. For example, consider a function <i>f</i> defined to allow only integer arguments but also guaranteed to detect and signal an error for non-integer arguments. Such a description would be internally inconsistent (that is, paradoxical) because the function's behavior is well-defined for non-integers. Yet we would not want this annoying paradox to force description of <i>f</i> as a function that accepts any kind of argument (just in case <i>f</i> is being called only as a quick way to signal an error, for example). Using the normal/exceptional distinction, we can say clearly that <i>f</i> accepts integers in the normal situation and signals an error in exceptional situations. Moreover, we can say that when we refer to the definition of a function informally, it is acceptable to speak only of its normal behavior. For example, we can speak informally about <i>f</i> as a function that accepts only integers without feeling that we are committing some awful fraud.</p>

<p>The separation of normal and exceptional situations is useful for a number of reasons, including the following:</p>

<ul>
	<li><b>Simplifying Assumptions</b>: A programmer may speed the development of a program by assuming that the program will be needed only for some normal case. In so doing, the programmer pushes off worrying about a level of detail that would only be distracting during the prototyping phase. Later, after it has been shown that the program works satisfactorily in normal situations, the programmer can "tighten up" the program to handle exceptional situations</li>
	<li><b>Presentation</b>: Simplifying assumptions can also be important after a program has been developed--when it is being read by another programmer. The person reading the code may want to first understand what it does in the normal situation and then later refine his understanding of it by inspecting its behavior in exceptional situations. If the code for dealing with the normal situation is thickly interspersed with code attempting to recognize and deal with exceptional situations, the reader's ability to decipher the intent of the program may be greatly diminished</li>
	<li><b>Modularity</b>: It frequently happens that the same exceptional situation can occur in many different places in a program; and, in many cases, the way it should be handled is the same throughout the program. For example, consider a program which is compiling a file from a remote machine. If the remote machine crashes, the compilation will probably want to simply fail no matter what routine was running. Languages should provide some way of centralizing the information about a program's behavior in such an exceptional situation so that it doesn't have to be needlessly repeated throughout the code for the program</li>
	<li><b>Efficiency</b>: In some cases, there may be efficiency reasons for considering some cases to be exceptional. For example, the compiled code for + will be less efficient if it must contain explicit checks for its arguments being non-numbers. Thus, an implementation may choose the interpreted + function to "signal an error" if invoked with bad arguments, but allow compiled calls to + to do just "do the wrong thing" if that situation arises.</li>
</ul>

<p>The Common Lisp Condition System encapsulates and formalises useful patterns of data and control flow that are useful in dealing with exceptional situations. Armed with the preceding conceptual background, we will now describe how to define conditions in Common Lisp, how to signal and handle them, and how to recover from scenarios where exceptional situations occur (such as through restarting).</p>

<h2>Starting Notes</h2>
<p>In this guide, we will use a contrived example of calculating the width from a rectangle when its area and height are known. A simple example of this function is below. In this contrived example, we will consider five scenarios, 1 normal and 4 erroneous, as noted in the table below. Try out each scenario to get a feel for this function.</p>

<code>
(defun rect-width-simple (area height)
  (/ area height))
 </code>

<table>
	<thead>
		<tr>
			<th>Type</th>
			<th>Function Call</th>
			<th>Output</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Normal</td>
			<td>(rect-width-simple 40 8)</td>
			<td>Returns 5</td>
		</tr>
		<tr>
			<td>Error - Divide by Zero</td>
			<td>(rect-width-simple 40 0)</td>
			<td>Returns a DIVISION-BY-ZERO error and throws us into the Debugger. Note the type of the error is "divis<b>ion</b>-by-zero" and not "divide-by-zero". In our example later, we will create a custom "divide-by-zero" condition type, but want to remind readers here that this differs slightly in naming to the standard error type for the same</td>
		</tr>
		<tr>
			<td>Error - Negative Height</td>
			<td>(rect-width-simple 40 -8)</td>
			<td>Returns -5. While the function successfully executes, this is an error as neither height nor width can be negative. Without instructing our programs to pick up on such implicit assumptions, we cannot expect them to catch such errors</td>
		</tr>
		<tr>
			<td>Error - Not a Number</td>
			<td>(rect-width-simple 40 "asdf")</td>
			<td>Returns a TYPE-ERROR (The value "asdf" is not of type NUMBER) and throws us into the debugger</td>
		</tr>
	</tbody>
</table>

<p>Note that the above table is not an exhaustive list of errors. For example it is missing the error of entering a negative area. I did this delibrately to stress that it is difficult to capture all possible errors and one should be mindful and not overconfidence of his or her ability's to do so. A careful, considered appraoch will lead to more errors captured and overall greater reliability of one's programs.</p>

<h2>Conditions</h2>
<h3>Background</h3>
<p>Let us formalise and codify the above table of errors through the concept of conditions and condition objects. Conditions are <i>interesting</i> situations in a program, one may say "exceptional" to keep in line with the terminology we used earlier, but it would also be good to keep our mind open and think of conditions as a general construct and not one limited to errors or to only the most exceptional situations. Errors can be defined as conditions in which normal program execution may not continue without some form of intervention (either interactively by the user or under some sort of program control). Our primary objective in most cases is to detect and handle errors.</p>

<p>Common Lisp takes an object-oriented approach to condition handling, as it allows for a more organised sharing of information related to condition handling. This approach has the following benefits over a more primitive text-based approach:</p>
<ul>
	<li>Conditions are classified according to subtype relationships, making it easy to test for categories of conditions</li>
	<li>Conditions have named slot values through which parameters are conveyed from the program that signals the condition to the program that handles it</li>
	<li>Inheritance of methods and slots reduces the amount of explicit specification necessary to achieve various interesting effects</li>
</ul>

<p>If the above (or below) is confusing, it is probably because you have not had much experience with the Common Lisp Object System (CLOS). It is well worth gaining proficiency in CLOS, but that is beyond the scope of this article. Consequently, we will try and keep our introduction of Common Lisp Conditions relatively simple and leave a more detailed purview to the reader.</p>

<h3>Code Examples</h3>
<p>In Common Lisp, all conditions are instances of the <mark>CONDITION</mark> class or one of its subclassses. Note that conditions are not standard objects, thus the treatment of condition objects is slightly different to CLOS objects and the standard more frequently talks about condition <i>types</i> as opposed to condition classes. Without labouring over this point too much, the main point here is that not all of mechanisms available to CLOS objects transfer over to CL condition types.</p>

<p>We can create condition types with the <mark>DEFINE-CONDITION</mark> macro and instances of condition types with the <mark>MAKE-INSTANCE</mark> function. To illustrate with an example, let us define two conditions type <mark2>divide-by-zero</mark2> and <mark2>negative-value</mark2>, the former being a simple condition of type error, the latter being a more complex example that has an attributes <mark2>desc</mark2> and <mark2>param</mark2> where we can store pertinent information about the condition when it is detected.</p>

<code>
(define-condition divide-by-zero (error) ())

(define-condition negative-value ()
  ((desc :initarg :desc :reader desc)
   (param :initarg :param :reader param))
  (:report (lambda (condition stream)
	     (format stream "Condition ~a detected for ~a."
		     (desc condition)
		     (param condition)))))
</code>

<p>In the above, the <mark>:INITARG</mark> keyword is used to name the keyword parameter used for setting the values of desc and param (:desc and :param respectively - refer below make-condition example), while the <mark>:reader</mark> keyword is used to define the accessor functions for getting the values of desc and param respectively (desc and param). Thus, the form <mark3>(desc condition)</mark3> is used to access the value stored in desc for the condition passed-in. The <mark>:report</mark> option allows for printing with the condition reporter (when <mark>*PRINT-ESCAPE*</mark> is NIL - refer below examples), which is the lambda function in the above. Note that we can use a constant string in place of the lambda function above.</p>

<p>To make an instance of a condition, we can use the <mark>MAKE-CONDITION</mark> function:</p>

<code>
	(make-condition 'divide-by-zero)
	(make-condition 'negative-value :desc "negative number"
	                                :param "height parameter")
</code>
<p>To end this section, note that a useful further reading is <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node346.html">29.5. Condition Types of CLTL2e</a>, which is a listing of the predefined condition types used by CL implementations and ones that you can use or subclass.</p>

<h2>Signalling Conditions</h2>
<p>Conceptually, signalling an error in a program is an admission by that program that it does not know how to continue and requires external intervention. Once an error is signalled, any decision about how to continue must come from the outside. The <mark>SIGNAL</mark> function signals a condition without requiring it to be handled by a condition handler. The <mark>ERROR</mark> function signals an error and requires the debugger to be entered if the condition is not handled.</p>

<p>Below is an example of rewriting our contrived RECT-WIDTH function to analyse its inputs and detect negative value and zero value inputs. In the below example, we illustrate three ways to specify conditions, noting the second or third way is what you will most likely use:</p>

<ol>
	<li>Supplying one argument - a condition object, as in the first example below</li>
	<li>Supplying arguments as one would for make-condition, as in the second example below</li>
	<li>Supplying arguments as one would do for the FORMAT function, but without the stream details, as in the third example below. In such approaches, the condition is of the default type as specified by the function called (e.g. error or warning)</li>
</ol>

<code>
(defun rect-width (area height)
  (cond ((equal height 0)
	 (signal (make-condition 'divide-by-zero)))
	((< height 0)
	 (signal 'negative-value :desc "negative number"
		 :param "height parameter"))
	((not (numberp height))
	 (error "Not a Number"))
	(t (/ area height))))
</code>

<h2>Handling Conditions</h2>
<h3>Introduction</h3>
<p>Once an exceptional situation is detected and a condition is signalled, it should be handled as not to cause errors or unintended consequences during the overall program's execution. In general it is not a good idea to ignore errors, because the whole point of errors is that they signal a deviation from the normal execution of a program and thus some action should be taken to ensure the intended evaluation of the program takes place (in line with user expectations).</p>

<p>The basic idea behind condition handling is as follows:</p>
<ol>
	<li>A piece of code called the <b>signaler </b> (such as SIGNAL or ERROR in the above) detects and announces the existence of an exceptional situation</li>
	<li>This initiates a search for and invocation of a <b>handler</b>, by progressively moving up the call stack. The handler is a piece of code that will attempt to deal appropriately with the situation signalled</li>
	<li>If a handler is found, it can handle the situation by <b>performing a non-local transfer of control</b> or decline to handle it, by not performing such a transfer. It is important to stress that the signalling of a condition announces that an exceptional situation has arisen that  cannot be handled by the code signalling the exception. Thus, a non-local transfer of control is required to relieve the signaller from its duties and allow for another, better equipped, function to handle the situation</li>
	<li>If a handler declines, other handlers are sought by moving progressively up the call stack</li>
	<li>If no handler is found or if all handlers that were found decline, the SIGNAL function will return nil, while the ERROR function will throw us into the debugger to handle the situation</li>
</ol>

<p>It is worth carefully re-reading the above process. The key insight here is that a function announcing an exceptional situation or error is not automatically unwound, but rather initiates a process of identifying the best approach to handling the situation. The programmer has control over the timing of unwinding the exceptional situation and we will later discuss how one can access the local state to deploy an appropriate recovery strategy to an exceptional situation. This is one of the key differences of the Common Lisp approach versus other languages where the act of signalling an error and unwinding the stack are not decoupled (discussed more in section 8.1 below).</p>

<p>As part of this approach, note that the lexical environment of the signaller may not be available to handlers. This is one of the reasons we take an objected-oriented approach to conditions, as it to allow us to expressively and explicitly represent the relevant state of exceptional situations through a flexible data structure.</p>

<h3>The Handler-Case Macro</h3>
<p>The HANDLER-CASE macro provides a structured abstraction of the required mechanisms to investigate conditions and transfer control to appropriate recovery strategies. Below is an example.</p>
<p>The first argument to this macro, <mark3>(rect-width-v2 area height)</mark3>, is the main <b>expresssion</b> to be evaluated. If this expression returns without any conditions signalled, its value is the value returned by the handler-case macro. Each of the remaining arguments in handler-case represent an <b>error-clause</b> to handled if signalled. The structure of these forms is as follows:</p>
<ul><li>The first element (e.g. "divide-by-zero", "negative-value" or the generic "error" which will catch any conditions of type error) represents the condition to be matched </li>
<li>The second element "(var)" binds the condition object passed-in by the signaller to the name "var"</li>
<li>The third and final element is the <b>body</b> to be executed if the condition is matched. For example, if a "negative-value" condition is signalled, handler-case will return 0 and also write the condition to stream (this example shows you how to print conditions, note the setting of *PRINT-ESCAPE* to NIL)</li>
</ul>

<p>Note that handler-case searches for conditions sequentially from top to down, thus a "divide-by-zero" error will match to the first condition in the below, and not the more general "error" condition at the end (even though it would otherwise match to both as we earlier defined "divide-by-zero" as a subclass of "error"). Note also that we didn't define conditions for non-numeric input of area, this error will be automatically generated by the compiler, will be of type error and fall into the last form below.</p>

<code>
(defun rect-width-handler-case (area height)
  (handler-case (rect-width-v2 area height)
    (divide-by-zero (var)
      (values 0 var))
    (negative-value (var)
      (values 0 (let ((*print-escape* nil))
                  (write var))))
    (error (var)
      (values nil var))))
</code>

<p>If the condition signalled by the expression matches any of the error-clauses, <b>the dynamic state is unwound appropriately and control is transferred to the body of the error-clause, after binding the condition object to var</b>. If no match is found, handler-case has effectively declined to handle the condition (by simply returning). When a handler declines, any returned values are ignored and the effect is the same as if the handler had been invisible to the mechanism seeking to find a handler. The next handler in line (i.e. higher up the call stack) will be tried, or if no such handler exists, the condition will go unhandled.</p>

<h3>The Handler-Bind Macro</h3>
<p>The Handler-Case Macro is easy(ier) to understand and works in many cases. However, it has one limitation in that the dynamic state of the program is unwound before the condition is handled. This is not a big issue if you pass-in all the required data through the condition object, however we did mention earlier that Common Lisp had the powerful ability to handle exceptional situations prior to unwinding the call stack. The Handler-Bind Macro is required to access this functionality. A fantastic example illustrating the differences is contained in <a href="http://weitz.de/cl-recipes/">Chapter 12 of Common Lisp Recipes</a>.</p>

<p>The handler-bind macro takes a slightly different form: the first argument is a list of handlers (e.g. three in the below, with condition types divide-by-zero, negative-value and error), followed by one or more forms to evaluate (just one form in the below - calculating rect-width). Thus, the handler-bind can wrap handlers around more than one form.</p>

<p>Another important note is that while in handler-case we integrate the handlers into the macro's body, we need to fully write these ourselves within a handler-bind macro. Thus, in our handler functions, we need to be able to perform non-local transfer of control if we want our handler to handle the condition (remember from earlier that a handler that does not provide this is said to decline the condition and any values returned by it are ignored).</p>

<p>We illustrate these concepts with the below example. Bear with us, it is a bit complicated, so carefully step through it.</p>

<ul>
	<li>We first define an example-handler-function, which returns 0 and also writes the condition to stream. Note that handlers can be any function. Note also that this handler does not perform any non-local transfer of control, so by itself, it cannot actually handler any condition signalled to it</li>
	<li>We then illustrate a "bad" example of a handler-bind macro. The issue here is that none of the handlers perform a non-local exit. If you were to test this out, for example by evaluating <mark4>(rect-width-v2 40 0)</mark4>, you will be thrown into the debugger as our handler-bind does not handle the error</li>
	<li>At the same time, try evaluating <mark4>(rect-width-v2 40 -5)</mark4>. Note how this does not throw you into the debugger. The reason for this is that in <mark3>rect-width-v2</mark3> we only signal the condition <mark4>negative-value</mark4>, and do not send it as an error. As you will recall, signal does not automatically require the condition to be handled, and accordingly we do not get thrown into the debugger here</li>
</ul>

<code>
(defun example-handler-function (condition)
  (let ((*print-escape* nil))
    (values 0 (write condition))))

(defun rect-width-handler-bind-bad (area height)
  (handler-bind
      ((divide-by-zero #'(lambda (condition)
                           (declare (ignore condition))
                          (values nil condition)))
       (negative-value #'example-handler-function)
       (error (lambda (condition)
                (values nil condition))))
    (rect-width-v2 area height)))
</code>

<p>Now lets look at a better implementation of this handler-bind:</p>
<ul>
	<li>First, lets define a new rect-width function that is a bit more descriptive than the last (explicitly specifying divide-by-zero error in particular)</li>
	<li>Note now with the "good" version of our handler-bind macro, we have enclosed the form within a block construct and perform non-local exits within the first and last handler</li>
	<li>Thus this function can successfully handle divide-by-zero and general errors, and declines to handle negative-value conditions (which as we mentioned earlier does not automatically throw us into the debugger)</li>
</ul>

<code>
(defun rect-width-v3 (area height)
  (cond ((equal height 0)
         (signal 'divide-by-zero))
        ((< height 0)
         (signal (make-condition 'negative-value :desc "Height is Negative")))
        ((< area 0)
         (signal 'negative-value :desc "Area is Negative"))
        (t (/ area height))))

(defun rect-width-handler-bind-good (area height)
  (let ((tag (gensym)))
    (block tag
      (handler-bind
          ((divide-by-zero #'(lambda (condition)
                               (return-from tag
                                 (values nil condition))))
           (negative-value #'example-handler-function)
           (error #'(lambda (condition)
                      (return-from tag (values nil condition)))))
        (rect-width-v3 area height)))))
</code>

<p>Finally, let us rewrite the above, but this time use Catch/Throw to allow us to perform non-local exits within handler functions that are not in the lexical scope of the handler-bind (i.e. when we split out our handler functions into their own lexical scopes via defining them in new functions via defun, such as example-handler-function). The following section provides a bit more detail on lexical vs. dynamic transfer of controls.</p>

<code>
(defun example-handler-function (condition)
  (let ((*print-escape* nil))
    (throw tag (values 0 (write condition)))))

(defun rect-width-handler-bind-good (area height)
  (let ((tag (gensym)))
    (catch tag
      (handler-bind
          ((divide-by-zero #'(lambda (condition)
                               (throw tag
                                 (values nil condition))))
           (negative-value #'example-handler-function)
           (error #'(lambda (condition)
                      (throw tag (values nil condition)))))
        (rect-width-v3 area height)))))
</code>


<h3>Ignore-Errors Macro</h3>
<p>To conclude this section, note that the Common Lisp standard provides a shortcut way, the <mark>IGNORE-ERRORS</mark> macro, to ignore any errors and simply return nil. This is generally not an advisable strategy in complete program, but is something that may be useful during prototyping to reduce the overall complexity of the program. Below is an example. Use with caution.</p>

<code>
;; Returns Nil:

(ignore-errors (/ 40 0))
</code>

<h2>Non-Local Transfer of Control</h2>
<p>In the preceding section, we made frequent mention of the requirement for non-local transfer of control for a handler to handle a condition. We will now take a brief detour to expand on these concepts as they are required for developing condition systems in Lisp.</p>

<h3>Block/Return-From: Lexical Non-Local Exits</h3>
<p>The <mark>BLOCK</mark> and <mark>RETURN-FROM</mark> special forms provide a structured <u>lexical</u> non-local exit facility. At any point lexically within a block construct, a return-from with the same name may be used to perform an immediate transfer of control to exist from the block.</p>

<p>Below are the relevant forms associated with this construct. The block construct executes each form from left to right, returning whatever is returned by the last form. If however a return or return-form form with the same name as that of the block is executed during the block, the results specified by the return or return-form are immediately returned as the value of the block constructy. Note that (return form) is identical in meaning to (return-from nil form), and returns from a block named nil. Blocks established implicitly by iteration constructs such as do are named nil, so that return will exit properly from such constructs.</p>

<p>The function rect-width-handler-bind-good-v1 above illustrates the block/return-from exit facility.</p>

<code class="pseudo">
;; Special Form:
(block name {form}*)

;; Special Form:
(return-from name [result])

;; Macro Form:
(return [result])
</code>

<h3>Catch/Throw: Dynamic Non-Local Exits</h3>

<p>Catches and throws provide the facility to exit from complex processes in a non-local, <u>dynamically</u> scoped manner. A catch form evaluates subforms in such a way that if a throw form is executed during such an evaluation, the evaluation is aborted at that point and the catch form immediately returns a value specified by the throw. Unlike block and return, which allow for exiting a block form from any point lexically within the body of the block, the catch/throw mechanism works even if the throw form is not textually within the body of the catch form. The throw need only occur within the extent (time span) of the evaluation of the body of the catch. This is analogous to the distinction between dynamically bound (special) variables and lexically bound (local) variables.</p>

<p>The function rect-width-handler-bind-good-v2 above illustrates the catch/throw exit facility.</p>

<code class="pseudo">
;; Special Form:
(catch tag {form}*)

;; Special Form:
(throw tag result)
</code>

<h3>Expressing Handler-Case through Handler-Bind (Optional Reading)</h3>
<p>The <a href="http://clhs.lisp.se/Body/m_hand_1.htm">Common Lisp HyperSpec</a> provides an example of how to replicate the handler-case macro through handler-bind. Below is the relevant extract of this. It's a bit too complicated for now, but something worth revisting once you understand these concepts better.</p>

<code class="pseudo">
(handler-case form
   (type1 (var1) . body1)
   (type2 (var2) . body2) ...)

;; is approximately equivalent to:

(block #1=#:g0001
  (let ((#2=#:g0002 nil))
    (tagbody
      (handler-bind ((type1 #'(lambda (temp)
                                      (setq #1# temp)
                                      (go #3=#:g0003)))
                    (type2 #'(lambda (temp)
                                     (setq #2# temp)
                                     (go #4=#:g0004))) ...)
      (return-from #1# form))
        #3# (return-from #1# (let ((var1 #2#)) . body1))
        #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))

;; and

(handler-case form
  (type1 (var1) . body1)
  ...
  (:no-error (varN-1 varN-2 ...) . bodyN))

;; is approximately equivalent to:

(block #1=#:error-return
 (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)
    (block #2=#:normal-return
      (return-from #1#
        (handler-case (return-from #2# form)
          (type1 (var1) . body1) ...)))))
</code>

<h3>Unwind Protect Mechanisms (Optional Reading)</h3>
<p>Sometimes it is necessary to evaluate a form and make sure that certain side effects take place after the form is evaluated. An example would be</p>

<code class="pseudo">
(progn (start-motor) 
       (drill-hole) 
       (stop-motor))
</code>

<p>The non-local exit facility of Common Lisp creates a situation in which the above code won't work, however: if drill-hole should do a throw to a catch that is outside of the progn form (perhaps because the drill bit broke), then (stop-motor) will never be evaluated (and the motor will presumably be left running). This is particularly likely if drill-hole causes a Lisp error and the user tells the error-handler to give up and abort the computation. In order to allow the example hole-drilling program to work, it can be rewritten using unwind-protect as follows:</p>

<code class="pseudo">
(unwind-protect 
  (progn (start-motor) 
         (drill-hole)) 
  (stop-motor))
</code>

<p>This example assumes that it is correct to call stop-motor even if the motor has not yet been started. Remember that an error or interrupt may cause an exit even before any initialization forms have been executed. Any state restoration code should operate correctly no matter where in the protected code an exit occurred. A better way for the above would be:</p>

<code class="pseudo">
(let ((motor-running nil)) 
  (unwind-protect 
    (progn (start-motor) ;; This function should set motor-running to t
           (drill-hole)) 
    (if motor-running stop-motor)))
</code>

<h3>Go/Tagbody (Optional Reading)</h3>
<p>Finally, for sake of completeness, Common Lisp also provides the Go/Tagbody construct to permit the use of the <mark>GO</mark> construct. If (go tag) is evaluated within a tagbody, control jumps to the part of the body labelled with the tag. As a matter of style, it is recommended that the user think twice before using a go. Most purposes of go can be accomplished with one of the iteration primitives, nested conditional forms, or return-from. If the use of go seems to be unavoidable, perhaps the control structure implemented by go should be packaged as a macro definition. For more details, refer to <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node91.html">7.8.5 The "Program Feature" of CLTL2e</a>.

<h2>Restarts</h2>
<p>We mentioned earlier that the handler-bind macro does not unwind the stack when handling exceptional situations. We can take this one step further with restarts, and be able to split the decision on how to handle a situation (handler-bind) from the actual code that performs the recovery (restarts). Thus, we have a piece of code deep down in the call stack signal a condition, have the decision on how to handle it at a higher level in the stack, and the actual code which performs the recovery somewhere in between. If this sounds all to complicated, you are in good company (with myself). However, for completeness of this article, lets go through the concepts and perhaps this level of complexity will prove worthwhile sometime in the future.</p>

<h3>The Restart-Case Macro</h3>
<p>First lets introduce the restart-case macro, which takes a similar form to handler-case. The first argument is a <b>restartable-form</b> to be evaluated. If this form finishies executing and returns any values (i.e. without signalling any conditions), its values are returned by restart-case and the macro's evaluation completes. The remainder of the arguments to the restart-case macro are restart clauses, whose first element names them (e.g. return-zero, new-height and new-width below), whose second argument are the parameters the clause accept & bind. We then have the option of specifying any of three optional parameters (:interactive, :report and :test), and then remaining forms form the body of the clause.</p>

<p>While the restartable-form is executing, any code make transfer control to one of the clauses (via <mark>INVOKE-RESTART</mark>, to be discussed shortly). If such a transfer occurs, the forms in the body of that clause is evaluated any values returned by the last such form is returned by the restart-case macro. In this case, the dynamic state is unwound appropriately (so that the restarts established around the restartable-form are no longer active) prior to execution of the clause.</p>

<p>Below is an example. The restartable-form is <mark4>rect-width-v2</mark4>. The :report option allows us to provide text to display at a debugger, while :interactive allows us to collect information (e.g. a correct input) from the user. Note that we use the helper function <mark2>prompt-value</mark2> to help collect this input, this is a useful function to keep on hand.</p>

<p>Finally, the last argument in each of the below restart clauses are the body of the clause which are evaluated and returned as the value of the restart-case macro, should that clause be invoked.</p>

<code>
(defun rect-width-restart-case (area height)
  (restart-case (rect-width-v2 area height)
    (return-zero ()
      :report "Return 0"
      0)
    (new-height (value)
      :report "Enter a new height (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new height"))
      (rect-width-v2 area value))
    (new-width (value)
      :report "Enter a new area (non-negative number)"
      :interactive (lambda () (prompt-value "Please enter a new area"))
      (rect-width-v2 value height))))

;; Credits Common Lisp Cookbook

(defun prompt-value (prompt)
  (format *query-io* prompt)  ;; *query-io*: the special stream to make user queries.
  (force-output *query-io*)   ;; Ensure the user sees what he types.
  (list (read *query-io*)))   ;; We must return a list.
 </code>

<p>Much of the above explanation is a direct extract of the <a href="http://clhs.lisp.se/Body/m_rst_ca.htm">Common Lisp HyperSpec</a>. It is a bit technical and I skipped some of the finer points, but at this stage, we have reached a level of complexity within Common Lisp that tutorials will not help as much and its best for you to directly read from the HyperSpec.</p>

<h3>Invoke-Restart and Find-Restart</h3>

<p>Now that we have our restart cases defined, we need to find and invoke them. We will use handler-bind here.</p> 

<code>
</code>

<h2>Notes</h2>
<h3>Comparison to Other Languages</h3>
<p>One of the main distinctions between Common Lisp's error handling from that of other programming languages is that Common Lisp decouples the act of signalling an error and handling one. This is well explained by Peter Seibel in <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">Chapter 19 Beyond Error Handling of Practical Common Lisp</a>, so let us re-use some extracts from that chapter:</p>
<div class="note"><p>The condition system is more flexible than exception systems because instead of providing a two-part division between the code that signals an error and the code that handles it, the condition system splits the responsibilities into three parts--signaling a condition, handling it, and restarting.</p>

<p>...</p>

<p>In most languages, errors are handled by returning from a failing function and giving the caller the choice of either recovering or failing itself. Some languages use the normal function return mechanism, while languages with exceptions return control by throwing or raising an exception. Exceptions are a vast improvement over using normal function returns, but both schemes suffer from a common flaw: while searching for a function that can recover, the stack unwinds, which means code that might recover has to do so without the context of what the lower-level code was trying to do when the error actually occurred.</p>

<p>...</p>

<p>Consider the hypothetical call chain of <i>high</i>, <i>medium</i>, <i>low</i>. If <i>low</i> fails and <i>medium</i> can't recover, the ball is in <i>high's</i> court. For <i>high</i> to handle the error, it must either do its job without any help from <i>medium</i> or somehow change things so calling <i>medium</i> will work and call it again. The first option is theoretically clean but implies a lot of extra code--a whole extra implementation of whatever it was <i>medium</i> was supposed to do. And the further the stack unwinds, the more work that needs to be redone. The second option--patching things up and retrying--is tricky; for <i>high</i> to be able to change the state of the world so a second call into <i>medium</i> won't end up causing an error in <i>low</i>, it'd need an unseemly knowledge of the inner workings of both <i>medium</i> and <i>low</i>, contrary to the notion that each function is a black box.</p>

<p>...</p>

<h4>The Lisp Way</h4>

<p>Common Lisp's error handling system gives you a way out of this conundrum by letting you separate the code that actually recovers from an error from the code that decides how to recover. Thus, you can put recovery code in low-level functions without committing to actually using any particular recovery strategy, leaving that decision to code in high-level functions.</p>
</div>

<p>At the end of the day, one can implement any system within any language. With that note, the main benefit of Common Lisp is being more naturally expressive of the useful distinction between normal situations, exceptional situations and the process for handling them. Thus, the conceptual background noted above is a worthwhile section to re-read, to ingrain some of the important conceptual benefits of carefully selecting appropriate error handling in your code.</p>

<h3>Acknowledgements</h3>
<p>Apart from Chapter 29 of CLTL2e, <a href="https://www.apress.com/gp/book/9781484211779">Common Lisp Recipes by Edmun Weitz</a>, <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp by Peter Seibel</a> and the <a href="https://lispcookbook.github.io/cl-cookbook/error_handling.html">Common Lisp Cookbook</a> were helpful to me to understand the Common Lisp Condition System. Professor Weitz's book is notable for its excellent walkthrough of the handler-bind macro and its illustration of how the call stack unwinds. The CL Cookbook had very clear walk throughs of the restart-case macro, which I believe was based on the blog article <a href="https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/">Conditions and Restarts in Common Lisp</a> by Timmy Jose. I have referenced Practical Common Lisp directly above, it provided a very good explaination of the benefits of the Common Lisp approach. Full credit for parts of the above article should go to these resources.</p>

<h3>Further Reading</h3>
<p>The second part of Chapter 29 of CLTL2e, <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node334.html">Program Interface to Condition System</a> and the Common Lisp HyperSpec will be relevant further reading after digesting this article. Another follow up would also be Kent Pitman's paper <a href="https://www.nhplace.com/kent/Papers/Condition-Handling-2001.html">Condition Handling in the Lisp Language Family</a>. Finally, <a href="https://www.apress.com/gp/book/9781484261330">The Common Lisp Condition System: Beyond Exception Handling with Control Flow Mechanisms</a> is a detailed book on this topic by Michal Herda, which has received <a href="https://www.amazon.ae/Common-Lisp-Condition-System-Mechanisms/dp/148426133X#customerReviews">good reviews online</a>.</p>

<h3>Contact Details</h3>
<p>For feedback, suggestions, or to add any resources you have written or are aware of to the above list, drop me an e-mail at ashok dot khanna at hotmail dot com. If you liked this article, do please star the example repo <a href="https://github.com/ashok-khanna/common-lisp-by-example">Common Lisp by Example</a>.</p>

</main>
	<script src="/scripts/copy-to-clipboard.js"></script>
</body>
</html>