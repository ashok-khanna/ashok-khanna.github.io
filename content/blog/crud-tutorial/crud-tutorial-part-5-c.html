<article>
<h1>Comprehensive Guide to Creating a Cloud-based Web App (contd.)</h1>

<h2>Part 9 — Domains & DNS</h2>
<p>In this section, we will connect our custom domain names to our web servers, one domain for the main website that faces the world and one for our Linux server (in the next part on security and SSL I will explain why we need this).</p>

<p>I host my domains on Google, but you can modify the below to whichever domain provider you use (although you may need to do things slightly differently).</p>

<h3>Linking your main website to a domain</h3>
<p>In your domain’s DNS settings, add the following custom CNAME resource record. CNAME map your custom domain name to another domain (but not to an IP address).</p>

<figure>
<img src="images/23.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>In our example above, we are mapping www.yourdomain.com to the domain of your CloudFront server. You can get your CloudFront domain name from your CloudFront console:</p>

<figure>
<img src="images/24.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>CNAME cannot be used on the root domains (i.e. naked domains without the www). That means, you can point www.yourdomain.com to your CloudFront domain, but you cannot point yourdomain.com (without the www) to your CloudFront domain.</p>

<p>In Google Domains, we can point yourdomain.com correctly via a synthetic record to forward all subdomains to www. See below:</p>

<figure>
<img src="images/25.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<h3>Linking your linux server to a domain</h3>
<p>In your domain’s settings (this is for the domain you want to link to your linux server, which will be different to the domain above — i.e. you need two domain names for this tutorial), add the following custom records.</p>

<p>When adding, replace the ip address 18.221.39.133 with the ip address of your linux server (refer to the start of the tutorial, where we set this).</p>

<figure>
<img src="images/26.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>The @ represents the root domain, so our A record is pointing our root domain, yourdomain.com (without the www), to the ip address of our linux server. We use A records to point to actual ip addresses.</p>

<p>The CNAME record points www.yourdomain.com to yourdomain.com (which is then pointed to the server’s ip address).</p>

<h2>Part 10 — Security & SSL</h2>
<p>Cyber Security is very important and a topic of its own. Our setup would be incomplete without some basic cybersecurity measures, so let us add some now.</p>

<h3>Okta Authentication</h3>
<p>Your data is very important to you. In the above, we have actually exposed our linux server and database to the world — a scary thought.</p>

<p>However, by adding, okta authentication above, we are able to restrict our database to only the users we want to grant access to. I’m sure that hackers can find a way around it, but for now, it is sufficient for us. When your app grows, you will need to invest in resources to strengthen its cyber security.</p>

<p>Two additional steps here. Now that we are hosting both our main website on a public domain, let us add this information to our Okta configuration to ensure it works correctly.</p>

<p>Within Okta, navigate to the General Settings of your Application, and change the URIs to reference the domain of your Angular website. Note that I changed the address to https as in the next step we will be enabling https for our domains and Okta requires https on public domains because of the additional security they provide.</p>

<figure>
<img src="images/27.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>Finally, edit your src/app/app.module.ts file to reference this domain and not localhost.</p>

<h3>SSL Certificates</h3>
<p>Google Chrome and other browsers are now mandating websites to be delivered over a secure mechanism through SSL certificates.</p>
<p>SSLs allow the client and the server to share encrypted information that can only be read if the correct key is possessed to decrypt (i.e. unlock) the message. At the start of the session, an SSL Handshake occurs between the client and server machines that establish a common session key to use for encryption and decryption.</p>

<p>One issue is the initial setup of the SSL connection is done without encryption (as neither party shares a common encryption key). This allows nefarious parties the opporutnity to interject themselves in the middle and pose themselves as the server to intercept the messages sent to and received from the client. These are called Man in the Middle (MITM) attacks.</p>

<p>To overcome this, web browsers use the concept of SSL certificates. SSL certificates are issued by reputable organisations (that browsers recognise as valid and reputable) and certify that the server that the client is talking to is indeed the end website that the client wants to visit and interact with.</p>

<p>We will now add ssl certificates to both our main website and our linux server to allow secured connections via HTTPS (on port 443).</p>

<h3>Adding an SSL certificate to our main website</h3>
<p>CloudFront can automatically generate an SSL certificate for our main website domain. As noted earlier, we need to generate an SSL certificate to link our custom domain to our CloudFront distribution.</p>

<p>Click into your CloudFront distribution and edit its general settings. Enter your custom domain into the Alternate Domain Names (CNAMEs) field. You will then need to click on the button to request a certificate from AWS Certificate Manager (ACM):</p>

<figure>
<img src="images/28.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>Note — your page will look slightly different, as it will have the option ‘Default CloudFront Certificate’ selected</p>

<p>We need to create a custom SSL certificate through ACM for our custom domain and cannot rely on the default CloudFront Certificate. This is because CloudFront does not know whether we truly own our domain, so we need to go through a process to verify this.</p>

<p>Follow the steps to request a certificate in ACM, using the domain name *.yourdomain.com to capture all subdomains and root domains (we want all of them to be attached to our SSL certificate):</p>

<figure>
<img src="images/29.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>On the next page, select DNS validation as your validation method. In Step 3, there is no need to add any tags for our tutorial, so just progress through the remaining steps to generate your certificate. ACM will give us a CNAME record that we need to add to our domain (in Google Domains for me, as Google hosts my domain):</p>

<figure>
<img src="images/30.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>Obviously, only somebody who has access to the domain can add a CNAME record, so this is an easy way for ACM to validate your claim to the domain.</p>

<p>Once you add this CNAME record, you will have two CNAME records in the DNS settings for your main domain. One for pointing your domain to CloudFront and one for validating the domain with ACM for the SSL certificate.</p>

<p>It will look something like the below (noting my CNAME record below is different to the above, because that was just an example — but in your case, the CNAME record you create above will be exactly what goes into the below):</p>

<figure>
<img src="images/31.png" alt="">
<figcaption>Fig. - </figcaption>
</figure>

<p>It will take ACM a few minutes to validate your domain, and subsequently generate an SSL certificate.</p>
<p>Now go back to your CloudFront distribution settings, select Custom SSL Certificate and link your recently created SSL to your domain (from the same page where you requested a custom SSL certificate, you can now find your newly created certificate and add it to your distribution). Save changes.</p>

<h3>Adding an SSL certificate to your linux server</h3>
<p>We will now add an SSL certificate to our linux server to allow us to access it via Angular through a secure HTTPS connection.</p>
<p>ACM does not currently support generating SSL certificates for our linux server, so we will use Let’s Encrypt to achieve this. Let’s Encrypt is a free, nonprofit Certificate Authority that is backed by some of the biggest names in technology.</p>

<p>Enter the following commands to install CertBot, a free linux application to create and install Let’s Encrypt certificates for nginx servers:</p>
<code>sudo apt-get update
sudo apt-get install software-properties-common
sudo apt-get-repository universe
sudo apt-get update
sudo apt-get install certbot python3-certbot-nginx</code>

<p>Now, before we run CertBot, let us amend our nginx configuration file /etc/nginx/sites-available/node to reference the custom domain we linked to our linux server at the end of Part 8. It should look like the below:</p>
<code>server {
   listen 80;
   server_name www.yourlinuxdomain.com yourlinuxdomain.com;
location / {
      proxy_set_header X-Forwarded-For $remote_addr;
      proxy_set_header Host $http_host;
      proxy_pass “http://127.0.0.1:8080”;
   }
}</code>

<p>We can now run certbot via the following command to get a certificate and have Certbot automatically edit your Nginx configuration to serve it:</p>
<code>sudo certbot --nginx</code>

<p>When prompted during the installation, select all the domains you want the certificate to apply to and then select to ‘Redirect — make all requests redirect to secure HTTPS access’.</p>
<p>Your nginx configuration file sites-available/node should update to something like this:</p>
<code>server {
   server_name www.yourlinuxdomain.com yourdomain.com;
   location / {
      proxy_set_header X-Forwarded-For $remote_addr;
      proxy_set_header Host $http_host;
      proxy_pass "http://127.0.0.1:8080";
   }
listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/yourlinuxdomain.com/fullchain.pem; # managed b
y Certbot
    ssl_certificate_key /etc/letsencrypt/live/yourlinuxdomain.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}server {
    if ($host = www.yourlinuxdomain.com) {
        return 301 https://$host$request_uri;
    } # managed by Certbot
if ($host = yourdomain.com) {
        return 301 https://$host$request_uri;
    } # managed by Certbot
listen 80;
   server_name www.yourlinuxdomain.com yourlinuxdomain.com;
    return 404; # managed by Certbot
}</code>

<p>Restart your nginx server for the changes to take effect:</p>
<code>sudo service nginx restart</code>

<p>And that’s it! Your connection to your linux serve is now secure.</p>
<p>Note: It took me a few attempts to correctly set up the above SSL. The following helped in debugging:</p>
<ul>
<li>Checking the JavaScript Console in my client side web browser to see what the error message (e.g. at first it said the certificate was invalid, and later it said it could not connect — for the first issue I had to fix my SSL configurations and for the second issue I had to start up my Express Server as it was not running at the time)</li>
<li>Deleting CertBot history via sudo certbot delete and then re-running sudo certbot --nginx</li>
<li>Checking that there were no errors in my nginx file via sudo nginx -t</li>
<li>Killing all my nginx servers via sudo killall nginx as I had 2 servers accidentally running at the same time and causing havoc</li>
<li>Monitoring activity on my 443 port via sudo tcpdump -i any port 443</li>
<li>Update your Angular app to point to your domain</li>
</ul>

<p>We can now update our Angular app to point to our custom domain that is hosting our linux server over https. Within your Angular project folder, open src/environments/environment.prod.ts to reference your custom domain (noting that we are now pointing to a https server):</p>
<code>export const environment = {
  production: true,
  serverUrl: 'https://www.yourlinuxdomain.com'
};</code>

<p>Rebuild your Angular project via ng build --prod and upload its files to your S3 bucket and making them public for the changes to take effect (deleting the previous files in S3 of course).</p>

<h2>Next Steps</h2>
<p>You have now established the foundational infrastructure of your web app. Test it out! Debug and get it working.</p>
<p>Time to move on to actually building your app and adding the necessary functionality to make it a success. Without having to worry about the network side of things for some time.</p>
<p>I would recommend studying more on MySQL (to understand how databases work and how you can manipulate them), a bit on Express.js (to understand how to interface with your database), a lot on Angular (to do the main programming for your web app) and some HTML & CSS (to improve the visual design of your app). Javascript powers both Node Express and Angular, so is worth learning too.</p>
<p>Enjoy!</p>
<p>P.s. let me know any bugs or suggestions for the above tutorial</p>

</article>
